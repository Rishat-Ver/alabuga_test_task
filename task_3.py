"""
Петя пришел на стажировку, и первая его задача была познакомиться с SQL.

У Пети есть табличка, состоящая из N строк и M столбцов,
значениями которой являются целые числа.
Каждой колонке соответствует уникальное имя — строка из латинских символов.
Пете задан запрос из Q ограничений вида:
ColumnNamek qk valk.

qk может принимать два значения:
1.	> — учитывать только те строки, где значения в ColumnNamek строго больше valk;
2.	< — учитывать только те строки, где значения в ColumnNamek строго меньше valk.

Задача Пети заключается в том, чтоб посчитать сумму во всех строках,
которые удовлетворяют всем ограничениям.
Юный стажер уже написал скрипт и вычислил ответ.
Но Петя волнуется, что где-то ошибся, поэтому просит вас перепроверить его вычисления.

ФОРМАТ ВВОДА:
На первой строке вводятся 3 числа N, M, Q (1≤N×M≤3⋅105, 1≤Q≤105) —
    количество строк, столбцов в таблице и количество ограничений в запросе.

В следующей строке вводятся через пробел M слов,
состоящих из латинских маленьких букв — название соответствующей колонки, каждая строка по длине не превосходит L (1≤L≤10)

Далее вводятся N строк, в каждой через пробел M целых чисел aij (−109≤aij≤109) — элементы i-ой строки.

Потом вводятся Q строк — ограничения к запросу.
Каждая строка имеет вид ColumnNamek qk valk (qk∈(<,>); −109≤valk≤109) — k-ое ограничение в формате, описанном в условии задачи.
Гарантируется, что ColumnNamek соответствует имени одной из колонок таблицы.

ФОРМАТ ВЫВОДА:
Выведите единственное значение S — сумму всех чисел в строках, удовлетворяющих всем заданным ограничениям.
Если никакая строка не удовлетворяет всем ограничениям — выведите в ответ 0.

Примечания:
Первый тестовый пример:
В табличке есть две строки:
1.	(a=1,b=1);
2.	(a=2,b=2);
Рассмотрим ограничения из запроса:
1.	первому ограничению «a<3» соответствуют обе строки: (1<3) и (2<3);
2.	второму ограничению «b>1» соответствует только вторая строка: неверно, что (1>1), но верно (2>1);
3.	третьему ограничению «b<3» соответствуют обе строки: (1<3) и (2<3).
Так как первая строка не соответствует одному из ограничений, она в ответе не учитывается.
В результате в ответ входит только вторая строка, сумма всех чисел в ней: 2+2=4
"""
from collections import OrderedDict


def dictionary_formation(colomn: list, rows: list[list[int]]) -> OrderedDict:
    lst = list(zip(colomn, *rows))
    dictionary = OrderedDict([(i[0], list(i[1:])) for i in lst])
    return dictionary

def func(rows: list[list[int]], colomn: list, dictionary: OrderedDict, conditions: list[list[str]]) -> int:
    result = 0
    for i in range(len(colomn)):
        row_sum = 0
        for condition in conditions:
            if not eval(f"{dictionary[condition[0]][i]}{condition[1]}{condition[2]}"):
                break
        else:
            row_sum = sum(rows[i])
        result += row_sum
    return result


if __name__ == '__main__':

    # n, m, q = map(int, input().split())
    # colomn = list(map(str, input().split()))
    # rows = [list(map(int, input().split())) for _ in range(n)]
    # conditions = [input().split() for _ in range(q)]
    # dictionary = dictionary_formation(colomn, rows)
    # print(func(rows, colomn, dictionary, conditions))

    n, m, q = 2, 2, 3
    colomn = ['a', 'b']
    rows = [[1, 1], [2, 2]]
    conditions = [['a', '<', '3'], ['b', '>', '1'], ['b', '<', '3']]
    dictionary = dictionary_formation(colomn, rows)
    assert func(rows, colomn, dictionary, conditions) == 4
    
    print("Test OK")
